use pest::error::Error;

use super::Rule;

pub fn prepare(path: &str, error: Error<Rule>) -> Error<Rule> {
	error.with_path(path).renamed_rules(|rule| {
		match *rule {
			Rule::EOI => "end of file",
			Rule::semicolon => "';'",
			Rule::colon => "':'",
			Rule::comma => "','",
			Rule::equals => "'='",
			Rule::lparent => "'('",
			Rule::rparent => "')'",
			Rule::lsquare => "'['",
			Rule::rsquare => "']'",
			Rule::lcurly => "'{'",
			Rule::rcurly => "'}'",
			Rule::asterisk => "'*'",
			Rule::rarrow => "'->'",
			Rule::range => "'..'",
			Rule::add => "'+'",
			Rule::subtract => "'-'",
			Rule::neg => "'-'",
			Rule::multiply => "'*'",
			Rule::divide => "'/'",
			Rule::modulo => "'%'",
			Rule::bit_and => "'&'",
			Rule::bit_or => "'|'",
			Rule::bit_xor => "'^'",
			Rule::lshift => "'<<'",
			Rule::rshift => "'>>'",
			Rule::eq => "'=='",
			Rule::neq => "'!='",
			Rule::gt => "'>'",
			Rule::lt => "'<'",
			Rule::geq => "'>='",
			Rule::leq => "'<='",
			Rule::and => "'&&'",
			Rule::or => "'||'",
			Rule::not => "'!'",
			Rule::deref => "'*'",
			Rule::r#ref => "'&'",
			Rule::ref_const => "'&const'",
			Rule::dot => "'.'",
			Rule::r#use => "keyword 'use'",
			Rule::r#type => "keyword 'type'",
			Rule::r#fn => "keyword 'fn'",
			Rule::r#struct => "keyword 'struct'",
			Rule::r#const => "keyword 'const'",
			Rule::r#static => "keyword 'static'",
			Rule::r#let => "keyword 'let'",
			Rule::r#if => "keyword 'if'",
			Rule::r#else => "keyword 'else'",
			Rule::r#loop => "keyword 'loop'",
			Rule::r#while => "keyword 'while'",
			Rule::r#for => "keyword 'for'",
			Rule::r#in => "keyword 'in'",
			Rule::r#return => "keyword 'return'",
			Rule::r#true => "keyword 'true'",
			Rule::r#false => "keyword 'false'",
			Rule::identifier => "identifier",
			Rule::path => "path",
			Rule::use_declaration => "use declaration",
			Rule::simple_type => "simple type",
			Rule::array_type => "array type",
			Rule::slice_type => "slice type",
			Rule::ref_type => "reference type",
			Rule::ref_const_type => "constant reference type",
			Rule::any_type => "any type",
			Rule::dec_integer => "decimal integer",
			Rule::bin_integer => "binary integer",
			Rule::oct_integer => "octal integer",
			Rule::hex_integer => "hexadecimal integer",
			Rule::integer => "integer",
			Rule::character => "character",
			Rule::inner => "inner item",
			Rule::string => "string",
			Rule::boolean => "boolean",
			Rule::array => "array",
			Rule::func_call => "function call",
			Rule::accessor => "accessor",
			Rule::indexer => "indexer",
			Rule::slicer => "slicer",
			Rule::exp_parent => "parenthesized expression",
			Rule::expression => "expression",
			Rule::lvalue_parent => "parenthesized lvalue",
			Rule::lvalue => "lvalue",
			Rule::simple_var_decl => "simple variable declaration",
			Rule::assign_var_decl => "assigned variable declaration",
			Rule::const_var_decl => "constant variable declaration",
			Rule::static_var_decl => "static variable declaration",
			Rule::var_decl => "variable declaration",
			Rule::global_var_decl => "variable declaration",
			Rule::block => "block",
			Rule::assign_statement => "assignment statement",
			Rule::return_statement => "return statement",
			Rule::func_statement => "function statement",
			Rule::if_statement => "if statement",
			Rule::if_else_statement => "if-else statement",
			Rule::while_statement => "while statement",
			Rule::loop_statement => "loop statement",
			Rule::for_statement => "for statement",
			Rule::statement => "statement",
			Rule::parameter => "parameter",
			Rule::parameter_list => "parameter list",
			Rule::func_declaration => "function declaration",
			Rule::field => "field",
			Rule::field_list => "field list",
			Rule::struct_declaration => "struct declaration",
			Rule::type_declaration => "type declaration",
			Rule::global_declaration => "global declaration",
			_ => "unnamed",
		}
		.to_owned()
	})
}
